#!/usr/bin/env python3

import subprocess
import asyncio
import aiohttp
import aiofiles
import json
import requests
import sys
import psutil
import os
import signal
import flicklib
import time
import logging
import atexit

import RPi.GPIO as GPIO
from gtts import gTTS
from datetime import datetime
from zoneinfo import ZoneInfo
from collections import deque


#debug=True

#User configured parameters START: --------------------------------------------------------------------------

# Kodi connection settings
KODI_HOST = "127.0.0.1"   # Change to your Kodi IP
KODI_PORT = 8080          # Default Kodi web server port
KODI_USER = "kodi"        # Change if you set a username
KODI_PASS = "kodi"        # Change if you set a password

# Use the specific IANA time zone identifer for local time
tz = ZoneInfo("America/Indiana/Indianapolis")

#delay imposed between flick executes
flick_interval=1

#ignore execute commands if delayed by this much from flick detection time
flick_expire=3

#Maximum garbage recognition before recalibration is forced
max_garbage=4

#Recalibrate every N seconds
recalibration_interval=120

#wether to use onboard LEDs for visual cue: RED -> don't do gestures ; GREEN -> open for gestures
use_leds=True

#Orientation: location of raspberry pi HDMI port
orientation=90



#Kodi actions when video player is active
action_video = {
       0: "Empty",
      11: "seekbackward",
      12: "bigstepforward",
      13: "seekforward",
      14: "bigstepback",
      15: "createbookmark",
      16: "pause",
      31: "volumedown",
      32: "volumeup"
}

#Kodi actions when video player is not active (UI navigation)
action_menu = {
       0: "Empty",
      11: "left",
      12: "up",
      13: "right",
      14: "down",
      15: "back",
      16: "select",
      31: "pageup",
      32: "pagedown"
}


#User configured paramters END: -----------------------------------------------------------------------------


#Adjust process priority
process = psutil.Process(os.getpid())
os_used = sys.platform
process.nice(-20)

# Create a new empty queue
c_queue = deque()
f_queue = deque()

#shutdown signal
c_code=0
#shutdown timer
c_time=time.time()
#reinit
reinitialize=True

#Airwheel results
A_Left  = 31
A_Right = 32

#Flick swipes
if orientation == 0:
    F_East,F_South,F_West,F_North = [ 11,12,13,14 ]
elif orientation == 90:
    F_East,F_South,F_West,F_North = [ 12,13,14,11 ]
elif orientation ==180:
    F_East,F_South,F_West,F_North = [ 13,14,11,12 ]
elif orientation == 270:
    F_East,F_South,F_West,F_North = [ 14,11,12,13 ]

#Flick Hold
F_Hover_High  = 15
F_Hover_Low   = 16

F_Garbage     = -1     #This will occur randomly and hence is suited only for screen wake up


garbage_count = 0
some_value = 5000


#recalibration timer
init_t=time.time()
run_t=time.time()

#timer for flick executes
exec_t=time.time()

#timer for airwheel executes, not really used except recordkeeping
exec_a=time.time()

#flick result
f_result=''

#when flick returned a recognition
f_time=time.time()

#airwheel result
a_result=''

#last X,Y,Z values
z_in = ''
x_in = ''
y_in = ''

#last rotation value
last_degree=0

#we have a video player screen
video_active=0

#video player is playing video or paused
video_playing=False

#Screensaver is active
screensaver_active=False

permit_recalibrate=True

local_time=datetime.now(tz)

#print(flicklib.__file__)


detection = {
       0: "Empty",
      11: "East",
      12: "South",
      13: "West",
      14: "North",
      15: "Hover High",
      16: "Hover Low",
      31: "Rotate Left",
      32: "Rotate Right"
}



# Configure the logging
logging.basicConfig(
    filename='/home/pi/bin/myflick.log',
    level=logging.INFO, # Log messages with severity INFO or higher
    format='%(asctime)s - %(levelname)s - %(message)s',
    filemode='a' # Use 'a' to append to the file, 'w' to overwrite
)

def cleanup_leds():
    if not use_leds:
       return
    logging.info("Resetting LEDS to default")
    os.system("echo mmc0 | sudo tee  /sys/class/leds/ACT/trigger")
    os.system("echo input | sudo tee /sys/class/leds/PWR/trigger")


atexit.register(cleanup_leds)
#ASYNCHRONOUS METHODS--------------------------------------------------------------------------------------------


# Send a JSON-RPC request to Kodi asynchronously
async def kodi_request_(method, params=None):
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": method
    }
    if params:
        payload["params"] = params

    auth = aiohttp.BasicAuth(KODI_USER, KODI_PASS) if KODI_USER and KODI_PASS else None

    try:
        async with aiohttp.ClientSession(auth=auth) as session:
            async with session.post(
                url=f"http://{KODI_HOST}:{KODI_PORT}/jsonrpc",
                json=payload,
                headers={"Content-Type": "application/json"}
            ) as resp:
                resp.raise_for_status()
                data = await resp.json()
                return data
    except aiohttp.ClientError as e:
        print(f"Network error: {e}")
    except json.JSONDecodeError:
        print("Invalid JSON response from Kodi")
    return None

async def video_seek_(player_id,seek_t):

    if player_id==0:
        return 0
        
    await kodi_request_("Player.Seek",{"playerid": player_id, "value": { "seconds": seek_t } } )

    return 0 


async def soft_beep_():
    filename = "/home/pi/bin/audio/softbeep.wav"
    
    proc = await asyncio.create_subprocess_exec(
        'aplay', '-q', filename,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    #print(f"Subprocess (mpg321) running with PID: {proc.pid}")

    stdout, stderr = await proc.communicate()
    

async def ack_beep_():
    filename = "/home/pi/bin/audio/doublebeep.wav"
    
    proc = await asyncio.create_subprocess_exec(
        'aplay', '-q', filename,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    #print(f"Subprocess (mpg321) running with PID: {proc.pid}")

    stdout, stderr = await proc.communicate()


async def ready_beep_():
    filename = "/home/pi/bin/audio/beep.wav"
    
    proc = await asyncio.create_subprocess_exec(
        'aplay', '-q', filename,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    #print(f"Subprocess (mpg321) running with PID: {proc.pid}")

    stdout, stderr = await proc.communicate()
    
    
async def blink_leds_():
    if not use_leds:
       return
    val=1
    bcount=0

    
    while bcount <6:

      if val == 1:
          #print("Green")
          async with aiofiles.open('/sys/class/leds/ACT/brightness', 'w') as f:
              await f.write("1")
          async with aiofiles.open('/sys/class/leds/PWR/brightness', 'w') as f:
              await f.write("0")
          val = await asyncio.sleep(0.2, result=2)
          

      if val == 2:
          #print("Red")
          async with aiofiles.open('/sys/class/leds/ACT/brightness', 'w') as f:
              await f.write("0")
          async with aiofiles.open('/sys/class/leds/PWR/brightness', 'w') as f:
              await f.write("1")
          val = await asyncio.sleep(0.2, result=1)

      bcount+=1

    await act_led_("1")  
    await pwr_led_("0")   

async def act_led_(l_state):
    if not use_leds:
       return
    async with aiofiles.open('/sys/class/leds/ACT/brightness', mode='w') as f:
            await f.write(l_state) 

async def pwr_led_(l_state):
    if not use_leds:
       return
    async with aiofiles.open('/sys/class/leds/PWR/brightness', mode='w') as f:
            await f.write(l_state) 

async def recalibrate_(): #recalibrate wrapped in an async function
    #print("Recalibration started")
    await asyncio.sleep(1)
    flicklib.recalibrate()

    #print("Recalibration finished")

async def speak_command_(text):
    filename = "/home/pi/bin/audio/"+text+".wav"
    
    proc = await asyncio.create_subprocess_exec(
        #"mpg321", "-q", "-o", "alsa", "-a", "hw:0.0", filename,
        "mpg321", "-q", filename,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    #print(f"Subprocess (mpg321) running with PID: {proc.pid}")

    stdout, stderr = await proc.communicate()
    
    #if proc.returncode == 0:
    #    print(f"Finished playing: {filename}")
    #else:
    #    print(f"Error playing {filename}. Exit code: {proc.returncode}")
    #    if stderr:
    #        print(f"Error message: {stderr.decode().strip()}")




async def execute_(command):
   global video_active
   global video_playing
   global screensaver_active
   global action_menu
   global action_video
   global f_time
   global local_time
   global exec_t

   if command>0:
    exec_t=time.time() 
    if video_active:
         v_command=action_video.get(command, "Invalid input")

         if command<30:
            local_time = datetime.now(tz)
            if screensaver_active:
                 logging.info("  \\----------------------------- SCREENAVER WAKE :  "+str(local_time))
                 await kodi_request_("Input.ExecuteAction", {"action": "backspace" })          
            
            if time.time()-f_time>flick_expire:
                 local_f_time = datetime.fromtimestamp(f_time)
                 logging.info("  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Dropped Delayed : "+str(local_f_time)+" Now: "+str(local_time))
                 return 1
            else:
                 logging.info("  \\----------------------------- EXECUTED :  "+str(local_time))
    
            if "seek" in v_command:
               #Seeking only when video is playing
               if video_playing:
                  await speak_command_(v_command)
                  seek_forward=60
                  seek_backward=-60
                  if v_command == "seekforward":
                     await video_seek_(video_active,seek_forward)
                  else:
                     await video_seek_(video_active,seek_backward)
               #Otherwise, showsubtitles with a flick backward and showtime with flick forward     
               else:
                  if v_command == "seekbackward":
                       await speak_command_("subtitles")
                       await kodi_request_("Input.ExecuteAction", {"action": "showsubtitles" })
                  if v_command == "seekforward":     
                       await speak_command_("showtime")
                       await kodi_request_("Input.ExecuteAction", {"action": "showtime" })  
                  await kodi_request_("Input.ExecuteAction", {"action": "pause" })         
         
            if "bigstepforward" in v_command:
               #stop if video is paused
               if not video_playing:
                  v_command="stop"
                  await speak_command_(v_command)
                  await kodi_request_("Input.ExecuteAction", {"action": v_command })
               # Otherwise, do bigstepforward   
               else:
                  await speak_command_(v_command)
                  await kodi_request_("Input.ExecuteAction", {"action": v_command })
               
            if "bigstepback" in v_command:
               #stop if video is paused and play the next item
               if not video_playing:
                  await speak_command_("playnext")
                  await kodi_request_("Input.ExecuteAction", {"action": "stop" })
                  while is_screen_video():
                    time.sleep(1)
                  time.sleep(1)
                  await kodi_request_("Input.ExecuteAction", {"action": "down" })
                  time.sleep(1)
                  await kodi_request_("Input.ExecuteAction", {"action": "select" })
               # Otherwise, do bigstepback   
               else:
                  await speak_command_(v_command)
                  await kodi_request_("Input.ExecuteAction", {"action": v_command })      
          
            if not "seek" in v_command and not "bigstep" in v_command:
               await speak_command_(v_command)
               await kodi_request_("Input.ExecuteAction", {"action": v_command })   
               
         if command>30:
               await kodi_request_("Input.ExecuteAction", {"action": v_command })   
    else:
         m_command=action_menu.get(command, "Invalid input")
         if m_command:
            await speak_command_(m_command) 
            await kodi_request_("Input.ExecuteAction", {"action": m_command })

    while f_queue:
            f_queue.popleft()
    return 1


async def decode(seq):
   global c_code
   global c_time
   global reinitialize
   reinitialize=False
   L_counter=0
   R_counter=0
   
   old_key=0
   if len(seq)>=5:
      
      while seq:
         key,value = seq.popleft()
 
         if old_key==0:
            old_key=key
         if key==31:
            if old_key==key:
               L_counter+=1
               
            else:
               L_counter=0
               
         if key==32:
            if old_key==key:
               R_counter+=1
            else:
               R_counter=0
             
               
         old_key=key

    
      if L_counter>=10:   
         c_code=1
         c_time=time.time()
         reinitialize=True
         logging.info('  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SHUTDOWN Stage 1 :  '+str(L_counter)+" Left Airwheel revolutions")  
         await speak_command_("warning")     
         
      if c_code==1 and R_counter>=10:
         c_code=2
         reinitialize=False
         c_time=time.time()
         logging.info('  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SHUTDOWN Stage 2 :  '+str(R_counter)+" Right Airwheel revolutions")
         logging.info('  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SHUTDOWN Stage 2 :  Shutdown in 30 seconds unless video playback resumes')
         await speak_command_("shutdownin30seconds")
         
   else:
      if time.time()-c_time>40 and c_code>=1:
         reinitialize=False
         logging.info('  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SHUTDOWN Stage 0 : Timer for Stage 2 expired ')  
         c_code=0
      


#SYNCHRONOUS METHODS----------------------------------------------------------------------------------------------

#Send a kodi_request synchronously
def kodi_request(method, params=None):
    """
    Send a JSON-RPC request to Kodi and return the parsed JSON response.
    """
    url = f"http://{KODI_HOST}:{KODI_PORT}/jsonrpc"
    headers = {"Content-Type": "application/json"}
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": method
    }
    if params:
        payload["params"] = params

    try:
        response = requests.post(url, json=payload, headers=headers, auth=(KODI_USER, KODI_PASS), timeout=5)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        print(f"Error communicating with Kodi: {e}")
        return None


def is_screen_video():

    """Check if Kodi is currently playing a video"""
    # Get active players
    players = kodi_request("Player.GetActivePlayers")
    
    if not players or "result" not in players:
        return 0


    for player in players["result"]:
        if player.get("type") == "video":

    # Find video player ID
             video_player = next((p for p in players["result"] if p["type"] == "video"), None)
             if not video_player:
                    return 0  # No video playing

             player_id = video_player["playerid"]
             
             return player_id
    else:
        return 0



def is_screensaver_active():
    result = False
    #Get player properties
    props = kodi_request("XBMC.GetInfoBooleans", { "booleans" : ["System.ScreenSaverActive"] })  
  
    if props and "result" in props:
        result =  props["result"]["System.ScreenSaverActive"] == True  # 0 means paused
    #print(props)
    #if result: 
    #     logging.info("  \\----------------------------- SCREENAVER active :  "+str(local_time))

    return result

def is_video_playing(player_id):


    if player_id==0:
        return False

    #Get player properties
    props = kodi_request("Player.GetProperties", { "playerid" : player_id, "properties" : [ "speed" ] })  
  
    if props and "result" in props:
        return props["result"]["speed"] == 1  # 0 means paused
    #print(props)
    
    return False



def video_seek(player_id,seek_t):

    if player_id==0:
        return 0

    props = kodi_request("Player.Seek",{"playerid": player_id, "value": { "seconds": seek_t } } )

    return 0



#Signals detection is complete
def ack_beep():
    #mpg321 can't decode beep correctly
    os.system("aplay -q /home/pi/bin/audio/doublebeep.wav")

#Signals ready for next detection
def ready_beep():
    #mpg321 can't decode beep correctly
    os.system("aplay -q /home/pi/bin/audio/beep.wav")

def warn_beep():
    os.system("aplay -q /home/pi/bin/audio/longbeep.wav")

def synth_command(text):

    if text=="":
      return

    res = gTTS(text=text, lang='en')
    filename = "/tmp/output.mp3"
    res.save(filename)
    
    os.system("mpg321 -q -o alsa -a 'hw:0,0' /tmp/output.mp3")    


def speak_command(text):
    filename = "/home/pi/bin/audio/"+text+".wav" 

    os.system("mpg321 -q -o alsa -a 'hw:0,0' "+filename)
  


def act_led(l_state):
    if not use_leds:
       return
    with open('/sys/class/leds/ACT/brightness', 'w') as f:
       f.write(l_state)

def pwr_led(l_state):
    if not use_leds:
       return
    with open('/sys/class/leds/PWR/brightness', 'w') as f:
       f.write(l_state)


def execute(command):
   global video_active
   global action_menu
   global action_video
   
   if command>0:

    if video_active:
         v_command=action_video.get(command, "Invalid input")
         if command<30:
            if "seek" in v_command:
               #Seeking only when video is playing
               if is_video_playing(is_screen_video()):
                  speak_command(v_command)
                  seek_forward=60
                  seek_backward=-60
                  if v_command == "seekforward":
                     video_seek(video_active,seek_forward)
                  else:
                     video_seek(video_active,seek_backward)
               #Otherwise, showsubtitles with a flick backward and showtime with flick forward     
               else:
                  if v_command == "seekbackward":
                       speak_command("subtitles")
                       kodi_request("Input.ExecuteAction", {"action": "showsubtitles" })
                  if v_command == "seekforward":     
                       speak_command("showtime")
                       kodi_request("Input.ExecuteAction", {"action": "showtime" })  
                  kodi_request("Input.ExecuteAction", {"action": "pause" })         
         
            if "bigstepforward" in v_command:
               #stop if video is paused
               if not is_video_playing(is_screen_video()):
                  v_command="stop"
                  speak_command(v_command)
                  kodi_request("Input.ExecuteAction", {"action": v_command })
               # Otherwise, do bigstepforward   
               else:
                  speak_command(v_command)
                  kodi_request("Input.ExecuteAction", {"action": v_command })
               
            if "bigstepback" in v_command:
               #stop if video is paused and play the next item
               if not is_video_playing(is_screen_video()):
                  speak_command("playnext")
                  kodi_request("Input.ExecuteAction", {"action": "stop" })
                  while is_screen_video():
                    time.sleep(1)
                  time.sleep(1)
                  kodi_request("Input.ExecuteAction", {"action": "down" })
                  time.sleep(1)
                  kodi_request("Input.ExecuteAction", {"action": "select" })
               # Otherwise, do bigstepback   
               else:
                  speak_command(v_command)
                  kodi_request("Input.ExecuteAction", {"action": v_command })      
          
            if not "seek" in v_command and not "bigstep" in v_command:
               speak_command(v_command)
               kodi_request("Input.ExecuteAction", {"action": v_command })   
               
         if command>30:
               kodi_request("Input.ExecuteAction", {"action": v_command })   
    else:
         m_command=action_menu.get(command, "Invalid input")
         if m_command:
            speak_command(m_command) 
            kodi_request("Input.ExecuteAction", {"action": m_command })

    return 1



#Asynchronous FLickLib methods for data retrieval----------------------------------------------------------------------------


@flicklib.move()
def move(x, y, z):
    global z_in
    global y_in
    global x_in

    z_in=z
    x_in=x
    y_in=y


@flicklib.flick()
def flick(i_type,start,finish):
    global z_in
    global f_result
    global f_time
    global permit_recalibrate
    global garbage_count

    permit_recalibrate=False

    #flicktxt = i_type +' : '+start + ' - ' + finish

    f_result=''

    if z_in=='':
       z_in=0

    if (i_type=='presence' or i_type=='hold') and (float(z_in) > 0.3):
            f_result='hover_high'

    if (i_type=='presence' or i_type=='hold') and (float(z_in) < 0.3):
            f_result='hover_low'

    if (i_type=='flick' and finish=='west'):
           f_result='move_right'

    if (i_type=='flick' and finish=='east'):
           f_result='move_left'

    if (i_type=='flick' and finish=='north'):
           f_result='move_down'

    if (i_type=='flick' and finish=='south'):
           f_result='move_up'

    if  (i_type=='garbage'):
           f_result='garbage'
           garbage_count+=1
           
    if f_result:
           f_time=time.time()
           f_queue.append((f_result,f_time))
              
    permit_recalibrate=True

@flicklib.airwheel()
def spinny(delta):
    global some_value
    global airwheeltxt
    global a_result
    global last_degree
    
    a_result=''

    some_value += delta
    if some_value < 0:
        some_value = 0
    if some_value > 10000:
        some_value = 10000

    if last_degree < some_value:
          a_result='rotated_right'
    elif last_degree > some_value:
          a_result='rotated_left'
    else:
          a_result=''
    
    last_degree = some_value


#Debug

#Request Message format si 12 bytes

def send16():  
    #Set runtime parameter request code
    #Test code is 16 bytes, returns 16 bytes

    #flicklib._stop_poll()       #[ set runtime param    ][Runtime param ID  ][ Reserved     ][  Argument 0            ][     Argument 1         ]
                       #[size=x10=16   ID=0xa2 ][ x1000 or LE 0010 ][ for response ]        
                       #  0      1    2      3       4    5             6     7        8     9     10    11      12    13    14     15         

    #Trigger recalibration OK
    #flicklib.i2c_write( [0x10, 0x00, 0x00, 0xa2,   0x00, 0x10,        0x00, 0x00,     0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00])
    
    """Data is : bytearray(b'\x10\x00\x04\x15\xa24\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
    Size is : 0x10
    Flags is : 0x0
    Sequence is : 0x4
    ID is : 0x15
    Param ID is : 0xa2
    Max Command size is : 0x34
    Error byte 0 is : 0x0
    Error byte 1 is : 0x0
    Argument 0 is : bytearray(b'\x00\x00\x00\x00')
    Argument 1 is : bytearray(b'\x00\x00\x00\x00')
    """

    #set gestures OK
    #flicklib.i2c_write([0x10, 0x00, 0x00, 0xA2, 0x85, 0x00, 0x00 ,0x00, 0x1F, 0x00, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF])

    """Data is : bytearray(b'\x10\x00\x04\x15\xa24\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
    Size is : 0x10
    Flags is : 0x0
    Sequence is : 0x4
    ID is : 0x15
    Param ID is : 0xa2
    Max Command size is : 0x34
    Error byte 0 is : 0x0
    Error byte 1 is : 0x0
    Argument 0 is : bytearray(b'\x00\x00\x00\x00')
    Argument 1 is : bytearray(b'\x00\x00\x00\x00')
    """

    handle_response16(flicklib._read_msg(16))


def handle_response16(data):

    #Response format in 16 bytes
                       #[size=x10=16 Flags Seq   ID=0xa2 ][ MsgID MaxCommandSize ][ Error code   ][   Argument 0 reserved  ][   Argument 1 reserved   ]     
                       #  0            1    2       3         4        5               6     7        8     9     10    11      12    13    14     15         
            
    print("Data is : "+str(data))
    #check if we have an error loaded in byte 7
    flicklib._handle_status_info(data) 
    d_size  = data.pop(0)
    if d_size == 0:
            print("No return message")
    else:
        print("Size is : "+str(hex(d_size)))
        d_flags = data.pop(0)
        print("Flags is : "+str(hex(d_flags)))
        d_seq   = data.pop(0)
        print("Sequence is : "+str(hex(d_seq)))
        d_ident = data.pop(0)
        print("ID is : "+str(hex(d_ident)))
        d_param = data.pop(0)
        print("Param ID is : "+str(hex(d_param)))
        d_cmd_size =  data.pop(0)
        print("Max Command size is : "+str(hex(d_cmd_size)))
        d_err0 =  data.pop(0)
        print("Error byte 0 is : "+str(hex(d_err0)))
        d_err1 =  data.pop(0)
        print("Error byte 1 is : "+str(hex(d_err1)))

        argument0=data[0:4]
        print("Argument 0 is : "+str(argument0))
   

        argument1=data[4:9]
        print("Argument 1 is : "+str(argument1))

    exit()


def send12():
    #Message Request code
    #Test code 12 bytes, returns 16 bytes

    flicklib._stop_poll()       

                       #Request message can only be performed with xA2 or x83 
                       #[size=x0c=12       ID=0x06 ][ MsgID=A2 ][    Reserved     ][      Param in LE            ] 
                       #  0      1    2      3           4         5    6    7        8     9     10    11              

    #Trigger request message : Param is 0x00, 0x10
    #flicklib.i2c_write( [0x0C, 0x00, 0x00, 0x06, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00 ] ) 

    #Response:
    """Data is : bytearray(b'\x10\x00\x04\xa2\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
    Size is : 0x10
    Flags is : 0x0
    Sequence is : 0x4
    ID is : 0xa2
    Param ID is : 0x0
    Max Command size is : 0x10
    Error byte 0 is : 0x0
    Error byte 1 is : 0x0
    Argument 0 is : bytearray(b'\x00\x00\x00\x00')
    Argument 1 is : bytearray(b'\x00\x00\x00\x00')
    """

    #Gesture HMM settings request message : Param is 0x85
    #flicklib.i2c_write( [0x0C, 0x00, 0x00, 0x06, 0xA2, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00 ])
  
    #Response:
    """Data is : bytearray(b'\x10\x00\x04\xa2\x85\x00\x00\x00\x1f\x00\x80\x00\xff\xff\xff\xff')
    Size is : 0x10
    Flags is : 0x0
    Sequence is : 0x4
    ID is : 0xa2
    Param ID is : 0x85
    Max Command size is : 0x0
    Error byte 0 is : 0x0
    Error byte 1 is : 0x0
    Argument 0 is : bytearray(b'\x1f\x00\x80\x00')
    Argument 1 is : bytearray(b'\xff\xff\xff\xff')"""


    #Calibration operation mode : Param 0x80    
    #flicklib.i2c_write( [0x0C, 0x00, 0x00, 0x06, 0xA2, 0x00, 0x00, 0x00,    0x80, 0x00, 0x00, 0x00 ]) 
    
    #Response:
    """Data is : bytearray(b'\x10\x00\x04\xa2\x80\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff')
    Size is : 0x10
    Flags is : 0x0
    Sequence is : 0x4
    ID is : 0xa2
    Param ID is : 0x80
    Max Command size is : 0x0
    Error byte 0 is : 0x0
    Error byte 1 is : 0x0
    Argument 0 is : bytearray(b'\x00\x00\x00\x00')
    Argument 1 is : bytearray(b'\xff\xff\xff\xff')"""

    #Experiments 0x01 to 0x0A returned error codes
    #flicklib.i2c_write( [0x0C, 0x00, 0x00, 0x06, 0xA2, 0x00, 0x00, 0x00,    0x0A, 0x00, 0x00, 0x00 ]) 


    handle_response16(flicklib._read_msg(16))

    exit()


def handle_response12(data):

    #Handle 12 byte response

    print("Data is : "+str(data))
    #check if we have an error loaded in byte 7
    flicklib._handle_status_info(data) 
    d_size  = data.pop(0)
    if d_size == 0:
            print("No return message")
    else:
        
        print("Size is : "+str(hex(d_size)))
        d_flags = data.pop(0)
        print("Flags is : "+str(hex(d_flags)))
        d_seq   = data.pop(0)
        print("Sequence is : "+str(hex(d_seq)))
        d_ident = data.pop(0)
        print("ID is : "+str(hex(d_ident)))
        d_param = data.pop(0)
        print("Param ID is : "+str(hex(d_param)))
        d_cmd_size =  data.pop(0)
        print("Max Command size is : "+str(hex(d_cmd_size)))
        d_err0 =  data.pop(0)
        print("Error byte 0 is : "+str(hex(d_err0)))
        d_err1 =  data.pop(0)
        print("Error byte 1 is : "+str(hex(d_err1)))
   
    exit()




#Main function-----------------------------------------------------------------------------------------------------------------------

async def main():

    global init_t
    global run_t
    global exec_t
    global exec_a
    global permit_recalibrate
    global reinitialize

    global o_result
    global video_active
    global video_playing
    global screensaver_active

    global a_result
    global f_result
    
    global c_code
    global c_time

    global z_in
    global x_in
    global y_in
    
    global detection
    global flick_interval
    global local_time

    global garbage_count
 
    init_t=time.time()
    exec_t=0
    exec_a=0
    
    result=1
    

    #Test code start-----------------------------------------------------------
    #Test code will end the script

    #send16()

    #send12()
    
    #Test code end------------------------------------------------------------
    
     
    # Create a lock
    execute_lock = asyncio.Lock()

    video_active =  is_screen_video()
    video_playing =  is_video_playing(video_active)
    if not video_playing:
        screensaver_active =  is_screensaver_active()
    else:
        screensaver_active = False

    flicklib.recalibrate() 
    
    # Update data window continuously until Control-C
    while True:
        o_result=0
        
        if len(f_queue)>0:
             f_result,f_time=f_queue.popleft()
             while f_queue:
                 f_queue.popleft()

        if not a_result:
          if not f_result:
             o_result=0
          else:
             if f_result=='hover_high':
                 f_result=''
                 o_result=F_Hover_High

             if f_result=='hover_low':
                 f_result=''
                 o_result=F_Hover_Low

             if f_result=='move_right':
                 f_result=''
                 o_result=F_West

             if f_result=='move_left':
                 f_result=''
                 o_result=F_East

             if f_result=='move_down':
                 f_result=''
                 o_result=F_North

             if f_result=='move_up':
                 f_result=''
                 o_result=F_South

             if f_result=='garbage':
                 f_result=''
                 o_result=F_Garbage

        else: 

          if a_result=='rotated_right':
              a_result=''
              o_result=A_Right

          if a_result=='rotated_left':
              a_result=''
              o_result=A_Left
    
        cycle_result=o_result
        o_result=''

        if result and time.time()-exec_t>flick_interval and cycle_result<=0:
              await ready_beep_()
              #Green light ready to recognize
              await act_led_("1")
              await pwr_led_("0")
              result=0  

        local_time = datetime.now(tz)
        if cycle_result>0:
             c_command=detection.get(cycle_result, "Invalid input")
             
             logging.info(f"{cycle_result:<5}"+" : "f"{c_command:<15}"+" Received at ->       "+str(local_time))

             #Only beep if detection is not airwheel
             if cycle_result<30 and cycle_result>0:
                await ack_beep_() 
                #Red light, processing flick result, no gestures allowed
                await act_led_("0")
                await pwr_led_("1")
                if time.time()-exec_t<flick_interval:
                   cycle_result=0                            # Setup for calibration instead  
                   logging.info('  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Dropped Ignored, too early ')
                   
                elif time.time()-exec_t>=flick_interval:
                   if execute_lock.locked():
                       logging.info('  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Dropped Busy ')  
                   async with execute_lock: 
                       #beep_ signals detection is complete
                       #logging.info('\\-----------------------------EXECUTED') # Detection came after 3 seconds and previous execute() function has returned
                      
                       #await ack_beep_()                   
                       #exec_t=time.time() 
                       result=await execute_(cycle_result)      #asynchronous version
                       
                
                   
             #No beeps necessary if airwheel is detected   
             if cycle_result>30:    
                   exec_a=time.time()
                   result=await execute_(cycle_result)
                   if not video_playing:
                       c_queue.append((cycle_result,exec_a)) 
                       
        
        #Garbage flick was detected, hand might be over board, shouldn't recalibrate in this case    
        if cycle_result<0:
             g_command="garbage"
             await soft_beep_()
             logging.info(f"{cycle_result:<5}"+" : "f"{g_command:<15}"+str(garbage_count)+"/"+str(max_garbage)+" Received ->       "+str(local_time))
             m_command="backspace"     #choose a benign kodi command to wake up the screen
             if not video_playing and screensaver_active:  
                await kodi_request_("Input.ExecuteAction", {"action": m_command })      #asynchronous version
                logging.info("  \\----------------------------- SCREEN WAKE :  "+str(local_time))

        #No detection in this cycle, detect if video is playing, so don't have to detect in execute(command)
        if cycle_result == 0:
             video_active =  is_screen_video()
             video_playing =  is_video_playing(video_active)
             if not video_playing:
                 screensaver_active = is_screensaver_active()
             else:
                 screensaver_active = False

             #Process the c_queue for shutdown sequence
             if not video_playing:
                 await decode(c_queue)
                 if time.time()-c_time>30 and c_code==2 and video_active:           #Video paused and timer countdown elapsed, shut down
                     logging.info('  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SHUTDOWN Stage 3 : Shutting Down ')  
                     await kodi_request_("Input.ExecuteAction", {"action": "stop" })
                     await speak_command_("shuttingdown")
                     os.system("sudo shutdown -h now")
 
                 if time.time()-c_time<30 and c_code==1 and video_active:           #Video paused and timer has not elapsed yet, do a board reset instead
                     if reinitialize:
                         flicklib.reinit()
                         #warn_beep()
                         #flicklib.recalibrate()
                         reinitialize=False

                         await speak_command_("boardreset") 
                         logging.info('  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SHUTDOWN Stage 0 :  Board Reset performed ')
                     
             else:
                 if time.time()-c_time<30 and c_code==2 or not video_active:
                     logging.info('  \\>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SHUTDOWN Stage 0 : Shutdown Aborted by User ')
                     await speak_command_("cancelshutdown")
                     
                     c_time=0 
                     c_code=0

             run_t=time.time()
             #if run_t-init_t>60:
             #Recalibrate every 60 seconds 
             if (run_t-init_t>recalibration_interval or garbage_count>=max_garbage) and permit_recalibrate:
                   if (x_in=='' or y_in=='' or z_in==''):
                        if garbage_count>=max_garbage:
                            warn_beep()    #Warn user with long beep -  hands off the board!

                        #Blink while recalibrating to warn user to move hands off the board.Recalibration starts after 1 second after start of blinking
                        led_task = asyncio.create_task(blink_leds_())
                        await recalibrate_()
                        await asyncio.gather(led_task)

                        garbage_count=0
                        logging.info('  >>>>>>>>>>>>>>>>>>>>>>>>>>>>> Recalibrated. <<<<<<<<<<<<<<<<<<<<<<<<<<<<< ')  
                        init_t=time.time()
             x_in=''
             y_in=''
             z_in=''
        
             
        cycle_result=0

        

        
        
        time.sleep(0.1) 


if __name__ == "__main__":
    asyncio.run(main())


